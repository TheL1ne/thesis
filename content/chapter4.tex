\chapter{Versuchsaufbau}
Für den Beweis, dass eine Erkennung von Netzwerkanomalien möglich ist, haben wir den Soll-Zustand in einer minimale Ontologie definiert. Diese dient wie bei anderen Anomalieerkennungsverfahren als Normalprofil des Systems\cite{ye2001anomaly}. Das Profil definiert die Bedingung, dass jeder Netzwerkknoten exakt einem der folgenden vier Klassen angehören muss: \label{chap:4:model}
\begin{enumerate}
\item\textbf{Typ A} dient als Abstraktion von Sensordaten. Knoten vom Typ A senden periodisch an Typ C. Sie besitzen also eine \textit{sendet-an}-Relation zu Typ C. Es werden keine Daten an Typ A gesendet außer Bestätigungen der erhaltenen Pakete.
\item\textbf{Typ B} ist eine Abstraktion einer Senke also eines Stellventils oder Motors. Dieser Knoten reagiert nur auf Anweisungen eines Knoten vom Typ C und bestätigt diese nach Ausführung. Typ B besitzt also in manchen Zeitslots eine \textit{empfängt-von}-Relation zu Typ C.
\item\textbf{Typ C} verkörpert in diesem Modell die Abstraktion von Middleware. Es kann sich hier in der Realität beispielsweise um einen Steuerungsknoten handeln. Dabei führt in unserem Beispiel jede zehnte Messung zu einem Sendevorgang zu Typ B. Daraus folgt, dass Typ C eine \textit{empfängt-von}-Relation zu Typ A und in manchen Zeitslots eine \textit{sendet-an}-Relation zu Typ B hat.
\item\textbf{Typ D} dient nur der Vollständigkeit und ist in realen Anwendungen optional. Es handelt sich hier um einen Datenbankknoten, der von jedem der anderen Knoten die jeweils empfangenen Daten protokolliert. Dies ist notwendig, damit wir später auswerten können ob von uns ausgelöste Anomalien auch erkannt wurden.
\end{enumerate}
Außerdem wurden die möglichen Beziehungen zwischen den Knoten definiert, welche speziell auf diesen Anwendungsfall zugeschnitten sind.

Die Knoten wurden als \Gls{mockup} in \textit{Golang}\cite{golang} realisiert. Als Verbindungstechnologien wurde ein übliches \textit{Remote-Procedure-Call}-Framework\cite{grpc} in Kombination mit einer einem Serialisierungsframework\cite{protobuf} genutzt. Usprünglich war es geplant die Knoten als Dockercontainer\cite{docker} zu starten. Doch auf Grund der Virtualisierung des Netzwerkes zwischen den Container innerhalb der \textit{Docker}-Laufzeitumgebung, war ein Zugriff auf die Pakete in diesem Netzwerk unmöglich. Aus diesem Grund liefen die Knoten als kompilierte \textit{Golang}-Programme.\\
Für die Anomalieerkennung kam neben der genannten Ontologie basierend auf \textit{OWL2}\cite{owl2} die \textit{OWL-Java-API}\cite{owlapi} zum Einsatz. Aufgrund der Limitierung der API auf Java, wurde der ganze Anomalieerkennungsalgorithmus in Java umgesetzt. Der zugrunde liegende Rechner wurde mit Windows 10 betrieben und zum Einsatz kam Java version \verb|1.8.0\_281|.\\
Mit Hilfe der \textit{OWL-Java-API} wurden Situationsdaten zur Wissensdatenbank der Ontologie hinzuzufügen. Diese Situationsdaten waren Interpretationen der in einem Zeitslot aufgezeichneten Pakete, die die Teilnehmer ausgetauscht haben. Zur Aufzeichnung der Pakete wurde \textit{JnetPcap}\cite{jnetpcap} als Bibliothek eingesetzt. Es war hier notwendig Pakete zu ignorieren, die nur zur Bestätigung der TCP-Übertragung genutzt wurden. Dadurch war es besser möglich sich auf die Pakete mit Inhalt zu fokussieren.\\
Da bereits andere Evaluationen die Schlussfolgerung zogen, dass der Batchmode vorzuziehen ist, wurden die Daten immer für kurze Zeitintervalle (im Beispiel vier Sekunden) aufgezeichnet und anhand der vorhandenen Daten, die Knoten und deren Beziehungen definiert. Nach der vollständigen Auswertung der Daten für den Zeitsraum wurde ein OWL-kompatibler \Gls{reasoner} zur Klassifikation genutzt. Hier kam \textit{Openlett}\cite{openlett} zum Einsatz. Dabei handelt es sich um eine Weiterentwicklung von \textit{Pellet}\cite{pellet} durch eine Open-Source-Community. Dieser Reasoner wurde vor allem wegen seiner Kompatibilität zu Version fünf der \textit{OWL-Java-API} genutzt, um ein möglichst aktuelles Bild zu zeigen.\\
In unserem Versuchsaufbau existiert von jedem Knotentyp genau eine Instanz und jeder Knoten außer Typ D wurde erweitert, um ein gewünschtes, annomales Verhalten für kurze Zeit zeigen zu können. Dadurch sind folgende Anomalien simulierbar:
\begin{enumerate}
\item ausbleibende Pakete (sowohl als Empfangsbestätigung als auch beim Senden)
\item deutlich verspätete Pakete
\item spontaner Nachrichtensturm (sogenanntes \textit{Flooding})
\end{enumerate}
Wir gehen davon aus, dass eine Anomalie vorhanden ist, wenn es zu Widersprüchen in den gefunden Instanzen und der definierten Ontologie kommt.